# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import logging

from os_faults.ansible import executor
from os_faults.api import cloud_management
from os_faults.api import node_collection
from os_faults.common import service

LOG = logging.getLogger(__name__)


class DevStackNode(node_collection.NodeCollection):

    def connect(self, network_name):
        raise NotImplementedError

    def disconnect(self, network_name):
        raise NotImplementedError


class KeystoneService(service.ServiceAsProcess):
    SERVICE_NAME = 'keystone'
    GREP = '[k]eystone-'
    RESTART_CMD = 'service apache2 restart'


class DevStackManagement(cloud_management.CloudManagement):
    NAME = 'devstack'
    DESCRIPTION = 'Single node DevStack management driver'
    NODE_CLS = DevStackNode
    SERVICE_NAME_TO_CLASS = {
        'keystone': KeystoneService,
    }
    SUPPORTED_SERVICES = list(SERVICE_NAME_TO_CLASS.keys())
    SUPPORTED_NETWORKS = ['all-in-one']
    CONFIG_SCHEMA = {
        'type': 'object',
        '$schema': 'http://json-schema.org/draft-04/schema#',
        'properties': {
            'address': {'type': 'string'},
            'username': {'type': 'string'},
            'private_key_file': {'type': 'string'},

        },
        'required': ['address', 'username'],
        'additionalProperties': False,
    }

    def __init__(self, cloud_management_params):
        super(DevStackManagement, self).__init__()

        self.address = cloud_management_params['address']
        self.username = cloud_management_params['username']
        self.private_key_file = cloud_management_params.get('private_key_file')

        self.cloud_executor = executor.AnsibleRunner(
            remote_user=self.username, private_key_file=self.private_key_file,
            become=True)
        self.host = None

    def verify(self):
        """Verify connection to the cloud."""
        task = {'command': 'hostname'}
        hostname = self.execute_on_cloud(
            [self.address], task)[0].payload['stdout']
        LOG.debug('DevStack hostname: %s', hostname)
        LOG.info('Connected to cloud successfully')

    def execute_on_cloud(self, hosts, task, raise_on_error=True):
        """Execute task on specified hosts within the cloud.

        :param hosts: List of host FQDNs
        :param task: Ansible task
        :param raise_on_error: throw exception in case of error
        :return: Ansible execution result (list of records)
        """
        if raise_on_error:
            return self.cloud_executor.execute(hosts, task)
        else:
            return self.cloud_executor.execute(hosts, task, [])

    def get_nodes(self, fqdns=None):
        if self.host is None:
            task = {'command': 'cat /sys/class/net/eth0/address'}
            mac = self.execute_on_cloud(
                [self.address], task)[0].payload['stdout']
            # TODO(astudenov): support fqdn
            self.host = node_collection.Host(ip=self.address, mac=mac,
                                             fqdn='')

        return self.NODE_CLS(cloud_management=self,
                             power_management=self.power_management,
                             hosts=[self.host])
